diff --git a/Makefile b/Makefile
index 328f9c6..e9a30cb 100644
--- a/Makefile
+++ b/Makefile
@@ -28,7 +28,8 @@ OBJS = \
   $K/sysfile.o \
   $K/kernelvec.o \
   $K/plic.o \
-  $K/virtio_disk.o
+  $K/virtio_disk.o \
+  $K/cas.o
 
 # riscv64-unknown-elf- or riscv64-linux-gnu-
 # perhaps in /opt/riscv/bin
diff --git a/kernel/cas.S b/kernel/cas.S
new file mode 100644
index 0000000..599352b
--- /dev/null
+++ b/kernel/cas.S
@@ -0,0 +1,13 @@
+# a0 holds address of memory location
+# a1 holds expected value
+# a2 holds desired value
+# a0 holds return value, 0 if successful, !0 otherwise
+.global cas
+cas:
+    lr.w t0, (a0) # Load original value.
+    bne t0, a1, fail # Doesnâ€™t match, so fail.
+    sc.w a0, a2, (a0) # Try to update.
+    jr ra # Return.
+fail:
+    li a0, 1 # Set return to failure.
+    jr ra # Return.
\ No newline at end of file
diff --git a/kernel/defs.h b/kernel/defs.h
index 3564db4..c9cc8e2 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -63,6 +63,9 @@ void            ramdiskrw(struct buf*);
 void*           kalloc(void);
 void            kfree(void *);
 void            kinit(void);
+void            inc_reference_count(uint64 pa);
+void            dec_reference_count(uint64 pa);
+int             get_reference_count(uint64 pa);
 
 // log.c
 void            initlog(int, struct superblock*);
@@ -145,6 +148,7 @@ void            trapinit(void);
 void            trapinithart(void);
 extern struct spinlock tickslock;
 void            usertrapret(void);
+int             cow_handler(pagetable_t pagetable, uint64 va);
 
 // uart.c
 void            uartinit(void);
@@ -171,6 +175,7 @@ int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
 
+
 // plic.c
 void            plicinit(void);
 void            plicinithart(void);
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index fa6a0ac..b441f14 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -9,34 +9,39 @@
 #include "riscv.h"
 #include "defs.h"
 
+#define NUM_PYS_PAGES ((PHYSTOP-KERNBASE) / PGSIZE)
 void freerange(void *pa_start, void *pa_end);
-
+extern uint64 cas(volatile void *addr, int expected, int newval);
 extern char end[]; // first address after kernel.
-                   // defined by kernel.ld.
+// defined by kernel.ld.
 
 struct run {
-  struct run *next;
+    struct run *next;
 };
 
 struct {
-  struct spinlock lock;
-  struct run *freelist;
+    struct spinlock lock;
+    struct run *freelist;
+    uint64 page_ref_count[NUM_PYS_PAGES];
 } kmem;
 
 void
 kinit()
 {
-  initlock(&kmem.lock, "kmem");
-  freerange(end, (void*)PHYSTOP);
+    initlock(&kmem.lock, "kmem");
+    memset(kmem.page_ref_count, 0, sizeof(kmem.page_ref_count));
+    freerange(end, (void*)PHYSTOP);
 }
 
 void
 freerange(void *pa_start, void *pa_end)
 {
-  char *p;
-  p = (char*)PGROUNDUP((uint64)pa_start);
-  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
-    kfree(p);
+    char *p;
+    p = (char*)PGROUNDUP((uint64)pa_start);
+    for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE){
+        kmem.page_ref_count[(((uint64)p-KERNBASE) / PGSIZE)] = 1;
+        kfree(p);
+    }
 }
 
 // Free the page of physical memory pointed at by v,
@@ -46,20 +51,24 @@ freerange(void *pa_start, void *pa_end)
 void
 kfree(void *pa)
 {
-  struct run *r;
+    struct run *r;
+
+    if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
+        panic("kfree");
 
-  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
-    panic("kfree");
+    dec_reference_count((uint64)pa);
+    if (get_reference_count((uint64)pa) > 0)
+        return;
 
-  // Fill with junk to catch dangling refs.
-  memset(pa, 1, PGSIZE);
+    // Fill with junk to catch dangling refs.
+    memset(pa, 1, PGSIZE);
 
-  r = (struct run*)pa;
+    r = (struct run*)pa;
 
-  acquire(&kmem.lock);
-  r->next = kmem.freelist;
-  kmem.freelist = r;
-  release(&kmem.lock);
+    acquire(&kmem.lock);
+    r->next = kmem.freelist;
+    kmem.freelist = r;
+    release(&kmem.lock);
 }
 
 // Allocate one 4096-byte page of physical memory.
@@ -68,15 +77,34 @@ kfree(void *pa)
 void *
 kalloc(void)
 {
-  struct run *r;
+    struct run *r;
+
+    acquire(&kmem.lock);
+    r = kmem.freelist;
+    if(r)
+        kmem.freelist = r->next;
+    release(&kmem.lock);
+
+    if(r)
+        memset((char*)r, 5, PGSIZE); // fill with junk
+
+    if(r)
+        inc_reference_count((uint64)r);
+
+    return (void*)r;
+}
 
-  acquire(&kmem.lock);
-  r = kmem.freelist;
-  if(r)
-    kmem.freelist = r->next;
-  release(&kmem.lock);
 
-  if(r)
-    memset((char*)r, 5, PGSIZE); // fill with junk
-  return (void*)r;
+void inc_reference_count(uint64 pa){
+    uint64 entry = (pa-KERNBASE) / PGSIZE;
+    while(cas(kmem.page_ref_count + entry, kmem.page_ref_count[entry], kmem.page_ref_count[entry] + 1));
 }
+
+void dec_reference_count(uint64 pa){
+    uint64 entry = (pa-KERNBASE) / PGSIZE;
+    while(cas(kmem.page_ref_count + entry, kmem.page_ref_count[entry], kmem.page_ref_count[entry] - 1));
+}
+
+int get_reference_count(uint64 pa){
+    return kmem.page_ref_count[(pa-KERNBASE) / PGSIZE];
+}
\ No newline at end of file
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 1691faf..24e8392 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -2,9 +2,9 @@
 static inline uint64
 r_mhartid()
 {
-  uint64 x;
-  asm volatile("csrr %0, mhartid" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, mhartid" : "=r" (x) );
+    return x;
 }
 
 // Machine Status Register, mstatus
@@ -14,28 +14,29 @@ r_mhartid()
 #define MSTATUS_MPP_S (1L << 11)
 #define MSTATUS_MPP_U (0L << 11)
 #define MSTATUS_MIE (1L << 3)    // machine-mode interrupt enable.
+#define PTE_COW (1L << 9)
 
 static inline uint64
 r_mstatus()
 {
-  uint64 x;
-  asm volatile("csrr %0, mstatus" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, mstatus" : "=r" (x) );
+    return x;
 }
 
-static inline void 
+static inline void
 w_mstatus(uint64 x)
 {
-  asm volatile("csrw mstatus, %0" : : "r" (x));
+    asm volatile("csrw mstatus, %0" : : "r" (x));
 }
 
 // machine exception program counter, holds the
 // instruction address to which a return from
 // exception will go.
-static inline void 
+static inline void
 w_mepc(uint64 x)
 {
-  asm volatile("csrw mepc, %0" : : "r" (x));
+    asm volatile("csrw mepc, %0" : : "r" (x));
 }
 
 // Supervisor Status Register, sstatus
@@ -49,30 +50,30 @@ w_mepc(uint64 x)
 static inline uint64
 r_sstatus()
 {
-  uint64 x;
-  asm volatile("csrr %0, sstatus" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, sstatus" : "=r" (x) );
+    return x;
 }
 
-static inline void 
+static inline void
 w_sstatus(uint64 x)
 {
-  asm volatile("csrw sstatus, %0" : : "r" (x));
+    asm volatile("csrw sstatus, %0" : : "r" (x));
 }
 
 // Supervisor Interrupt Pending
 static inline uint64
 r_sip()
 {
-  uint64 x;
-  asm volatile("csrr %0, sip" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, sip" : "=r" (x) );
+    return x;
 }
 
-static inline void 
+static inline void
 w_sip(uint64 x)
 {
-  asm volatile("csrw sip, %0" : : "r" (x));
+    asm volatile("csrw sip, %0" : : "r" (x));
 }
 
 // Supervisor Interrupt Enable
@@ -82,15 +83,15 @@ w_sip(uint64 x)
 static inline uint64
 r_sie()
 {
-  uint64 x;
-  asm volatile("csrr %0, sie" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, sie" : "=r" (x) );
+    return x;
 }
 
-static inline void 
+static inline void
 w_sie(uint64 x)
 {
-  asm volatile("csrw sie, %0" : : "r" (x));
+    asm volatile("csrw sie, %0" : : "r" (x));
 }
 
 // Machine-mode Interrupt Enable
@@ -100,97 +101,97 @@ w_sie(uint64 x)
 static inline uint64
 r_mie()
 {
-  uint64 x;
-  asm volatile("csrr %0, mie" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, mie" : "=r" (x) );
+    return x;
 }
 
-static inline void 
+static inline void
 w_mie(uint64 x)
 {
-  asm volatile("csrw mie, %0" : : "r" (x));
+    asm volatile("csrw mie, %0" : : "r" (x));
 }
 
 // supervisor exception program counter, holds the
 // instruction address to which a return from
 // exception will go.
-static inline void 
+static inline void
 w_sepc(uint64 x)
 {
-  asm volatile("csrw sepc, %0" : : "r" (x));
+    asm volatile("csrw sepc, %0" : : "r" (x));
 }
 
 static inline uint64
 r_sepc()
 {
-  uint64 x;
-  asm volatile("csrr %0, sepc" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, sepc" : "=r" (x) );
+    return x;
 }
 
 // Machine Exception Delegation
 static inline uint64
 r_medeleg()
 {
-  uint64 x;
-  asm volatile("csrr %0, medeleg" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, medeleg" : "=r" (x) );
+    return x;
 }
 
-static inline void 
+static inline void
 w_medeleg(uint64 x)
 {
-  asm volatile("csrw medeleg, %0" : : "r" (x));
+    asm volatile("csrw medeleg, %0" : : "r" (x));
 }
 
 // Machine Interrupt Delegation
 static inline uint64
 r_mideleg()
 {
-  uint64 x;
-  asm volatile("csrr %0, mideleg" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, mideleg" : "=r" (x) );
+    return x;
 }
 
-static inline void 
+static inline void
 w_mideleg(uint64 x)
 {
-  asm volatile("csrw mideleg, %0" : : "r" (x));
+    asm volatile("csrw mideleg, %0" : : "r" (x));
 }
 
 // Supervisor Trap-Vector Base Address
 // low two bits are mode.
-static inline void 
+static inline void
 w_stvec(uint64 x)
 {
-  asm volatile("csrw stvec, %0" : : "r" (x));
+    asm volatile("csrw stvec, %0" : : "r" (x));
 }
 
 static inline uint64
 r_stvec()
 {
-  uint64 x;
-  asm volatile("csrr %0, stvec" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, stvec" : "=r" (x) );
+    return x;
 }
 
 // Machine-mode interrupt vector
-static inline void 
+static inline void
 w_mtvec(uint64 x)
 {
-  asm volatile("csrw mtvec, %0" : : "r" (x));
+    asm volatile("csrw mtvec, %0" : : "r" (x));
 }
 
 static inline void
 w_pmpcfg0(uint64 x)
 {
-  asm volatile("csrw pmpcfg0, %0" : : "r" (x));
+    asm volatile("csrw pmpcfg0, %0" : : "r" (x));
 }
 
 static inline void
 w_pmpaddr0(uint64 x)
 {
-  asm volatile("csrw pmpaddr0, %0" : : "r" (x));
+    asm volatile("csrw pmpaddr0, %0" : : "r" (x));
 }
 
 // use riscv's sv39 page table scheme.
@@ -200,103 +201,103 @@ w_pmpaddr0(uint64 x)
 
 // supervisor address translation and protection;
 // holds the address of the page table.
-static inline void 
+static inline void
 w_satp(uint64 x)
 {
-  asm volatile("csrw satp, %0" : : "r" (x));
+    asm volatile("csrw satp, %0" : : "r" (x));
 }
 
 static inline uint64
 r_satp()
 {
-  uint64 x;
-  asm volatile("csrr %0, satp" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, satp" : "=r" (x) );
+    return x;
 }
 
 // Supervisor Scratch register, for early trap handler in trampoline.S.
-static inline void 
+static inline void
 w_sscratch(uint64 x)
 {
-  asm volatile("csrw sscratch, %0" : : "r" (x));
+    asm volatile("csrw sscratch, %0" : : "r" (x));
 }
 
-static inline void 
+static inline void
 w_mscratch(uint64 x)
 {
-  asm volatile("csrw mscratch, %0" : : "r" (x));
+    asm volatile("csrw mscratch, %0" : : "r" (x));
 }
 
 // Supervisor Trap Cause
 static inline uint64
 r_scause()
 {
-  uint64 x;
-  asm volatile("csrr %0, scause" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, scause" : "=r" (x) );
+    return x;
 }
 
 // Supervisor Trap Value
 static inline uint64
 r_stval()
 {
-  uint64 x;
-  asm volatile("csrr %0, stval" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, stval" : "=r" (x) );
+    return x;
 }
 
 // Machine-mode Counter-Enable
-static inline void 
+static inline void
 w_mcounteren(uint64 x)
 {
-  asm volatile("csrw mcounteren, %0" : : "r" (x));
+    asm volatile("csrw mcounteren, %0" : : "r" (x));
 }
 
 static inline uint64
 r_mcounteren()
 {
-  uint64 x;
-  asm volatile("csrr %0, mcounteren" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, mcounteren" : "=r" (x) );
+    return x;
 }
 
 // machine-mode cycle counter
 static inline uint64
 r_time()
 {
-  uint64 x;
-  asm volatile("csrr %0, time" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("csrr %0, time" : "=r" (x) );
+    return x;
 }
 
 // enable device interrupts
 static inline void
 intr_on()
 {
-  w_sstatus(r_sstatus() | SSTATUS_SIE);
+    w_sstatus(r_sstatus() | SSTATUS_SIE);
 }
 
 // disable device interrupts
 static inline void
 intr_off()
 {
-  w_sstatus(r_sstatus() & ~SSTATUS_SIE);
+    w_sstatus(r_sstatus() & ~SSTATUS_SIE);
 }
 
 // are device interrupts enabled?
 static inline int
 intr_get()
 {
-  uint64 x = r_sstatus();
-  return (x & SSTATUS_SIE) != 0;
+    uint64 x = r_sstatus();
+    return (x & SSTATUS_SIE) != 0;
 }
 
 static inline uint64
 r_sp()
 {
-  uint64 x;
-  asm volatile("mv %0, sp" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("mv %0, sp" : "=r" (x) );
+    return x;
 }
 
 // read and write tp, the thread pointer, which holds
@@ -304,31 +305,31 @@ r_sp()
 static inline uint64
 r_tp()
 {
-  uint64 x;
-  asm volatile("mv %0, tp" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("mv %0, tp" : "=r" (x) );
+    return x;
 }
 
-static inline void 
+static inline void
 w_tp(uint64 x)
 {
-  asm volatile("mv tp, %0" : : "r" (x));
+    asm volatile("mv tp, %0" : : "r" (x));
 }
 
 static inline uint64
 r_ra()
 {
-  uint64 x;
-  asm volatile("mv %0, ra" : "=r" (x) );
-  return x;
+    uint64 x;
+    asm volatile("mv %0, ra" : "=r" (x) );
+    return x;
 }
 
 // flush the TLB.
 static inline void
 sfence_vma()
 {
-  // the zero, zero means flush all TLB entries.
-  asm volatile("sfence.vma zero, zero");
+    // the zero, zero means flush all TLB entries.
+    asm volatile("sfence.vma zero, zero");
 }
 
 
@@ -349,6 +350,8 @@ sfence_vma()
 
 #define PTE2PA(pte) (((pte) >> 10) << 12)
 
+#define VA2PA(v) (((int) (v)) - KERNBASE)
+
 #define PTE_FLAGS(pte) ((pte) & 0x3FF)
 
 // extract the three 9-bit page table indices from a virtual address.
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..2eaa374 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -15,18 +15,19 @@ extern char trampoline[], uservec[], userret[];
 void kernelvec();
 
 extern int devintr();
+extern pte_t * walk(pagetable_t pagetable, uint64 va, int alloc);
 
 void
 trapinit(void)
 {
-  initlock(&tickslock, "time");
+    initlock(&tickslock, "time");
 }
 
 // set up to take exceptions and traps while in the kernel.
 void
 trapinithart(void)
 {
-  w_stvec((uint64)kernelvec);
+    w_stvec((uint64)kernelvec);
 }
 
 //
@@ -36,51 +37,59 @@ trapinithart(void)
 void
 usertrap(void)
 {
-  int which_dev = 0;
-
-  if((r_sstatus() & SSTATUS_SPP) != 0)
-    panic("usertrap: not from user mode");
-
-  // send interrupts and exceptions to kerneltrap(),
-  // since we're now in the kernel.
-  w_stvec((uint64)kernelvec);
+    int which_dev = 0;
+
+    if((r_sstatus() & SSTATUS_SPP) != 0)
+        panic("usertrap: not from user mode");
+
+    // send interrupts and exceptions to kerneltrap(),
+    // since we're now in the kernel.
+    w_stvec((uint64)kernelvec);
+
+    struct proc *p = myproc();
+
+    // save user program counter.
+    p->trapframe->epc = r_sepc();
+    if(r_scause() == 13 || r_scause() == 15){
+        uint64 va = r_stval(); // va that caused tha trap
+        if(cow_handler(p->pagetable, va) != 0){
+            printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+            printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+            p->killed = 1;
+        }
+    }
 
-  struct proc *p = myproc();
-  
-  // save user program counter.
-  p->trapframe->epc = r_sepc();
-  
-  if(r_scause() == 8){
-    // system call
+    else if(r_scause() == 8){
+        // system call
 
-    if(p->killed)
-      exit(-1);
+        if(p->killed)
+            exit(-1);
 
-    // sepc points to the ecall instruction,
-    // but we want to return to the next instruction.
-    p->trapframe->epc += 4;
+        // sepc points to the ecall instruction,
+        // but we want to return to the next instruction.
+        p->trapframe->epc += 4;
 
-    // an interrupt will change sstatus &c registers,
-    // so don't enable until done with those registers.
-    intr_on();
+        // an interrupt will change sstatus &c registers,
+        // so don't enable until done with those registers.
+        intr_on();
 
-    syscall();
-  } else if((which_dev = devintr()) != 0){
-    // ok
-  } else {
-    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
-    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
-    p->killed = 1;
-  }
+        syscall();
+    } else if((which_dev = devintr()) != 0){
+        // ok
+    } else {
+        printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+        printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+        p->killed = 1;
+    }
 
-  if(p->killed)
-    exit(-1);
+    if(p->killed)
+        exit(-1);
 
-  // give up the CPU if this is a timer interrupt.
-  if(which_dev == 2)
-    yield();
+    // give up the CPU if this is a timer interrupt.
+    if(which_dev == 2)
+        yield();
 
-  usertrapret();
+    usertrapret();
 }
 
 //
@@ -89,83 +98,83 @@ usertrap(void)
 void
 usertrapret(void)
 {
-  struct proc *p = myproc();
-
-  // we're about to switch the destination of traps from
-  // kerneltrap() to usertrap(), so turn off interrupts until
-  // we're back in user space, where usertrap() is correct.
-  intr_off();
-
-  // send syscalls, interrupts, and exceptions to trampoline.S
-  w_stvec(TRAMPOLINE + (uservec - trampoline));
-
-  // set up trapframe values that uservec will need when
-  // the process next re-enters the kernel.
-  p->trapframe->kernel_satp = r_satp();         // kernel page table
-  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
-  p->trapframe->kernel_trap = (uint64)usertrap;
-  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
-
-  // set up the registers that trampoline.S's sret will use
-  // to get to user space.
-  
-  // set S Previous Privilege mode to User.
-  unsigned long x = r_sstatus();
-  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
-  x |= SSTATUS_SPIE; // enable interrupts in user mode
-  w_sstatus(x);
-
-  // set S Exception Program Counter to the saved user pc.
-  w_sepc(p->trapframe->epc);
-
-  // tell trampoline.S the user page table to switch to.
-  uint64 satp = MAKE_SATP(p->pagetable);
-
-  // jump to trampoline.S at the top of memory, which 
-  // switches to the user page table, restores user registers,
-  // and switches to user mode with sret.
-  uint64 fn = TRAMPOLINE + (userret - trampoline);
-  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);
+    struct proc *p = myproc();
+
+    // we're about to switch the destination of traps from
+    // kerneltrap() to usertrap(), so turn off interrupts until
+    // we're back in user space, where usertrap() is correct.
+    intr_off();
+
+    // send syscalls, interrupts, and exceptions to trampoline.S
+    w_stvec(TRAMPOLINE + (uservec - trampoline));
+
+    // set up trapframe values that uservec will need when
+    // the process next re-enters the kernel.
+    p->trapframe->kernel_satp = r_satp();         // kernel page table
+    p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
+    p->trapframe->kernel_trap = (uint64)usertrap;
+    p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
+
+    // set up the registers that trampoline.S's sret will use
+    // to get to user space.
+
+    // set S Previous Privilege mode to User.
+    unsigned long x = r_sstatus();
+    x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
+    x |= SSTATUS_SPIE; // enable interrupts in user mode
+    w_sstatus(x);
+
+    // set S Exception Program Counter to the saved user pc.
+    w_sepc(p->trapframe->epc);
+
+    // tell trampoline.S the user page table to switch to.
+    uint64 satp = MAKE_SATP(p->pagetable);
+
+    // jump to trampoline.S at the top of memory, which
+    // switches to the user page table, restores user registers,
+    // and switches to user mode with sret.
+    uint64 fn = TRAMPOLINE + (userret - trampoline);
+    ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);
 }
 
 // interrupts and exceptions from kernel code go here via kernelvec,
 // on whatever the current kernel stack is.
-void 
+void
 kerneltrap()
 {
-  int which_dev = 0;
-  uint64 sepc = r_sepc();
-  uint64 sstatus = r_sstatus();
-  uint64 scause = r_scause();
-  
-  if((sstatus & SSTATUS_SPP) == 0)
-    panic("kerneltrap: not from supervisor mode");
-  if(intr_get() != 0)
-    panic("kerneltrap: interrupts enabled");
-
-  if((which_dev = devintr()) == 0){
-    printf("scause %p\n", scause);
-    printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
-    panic("kerneltrap");
-  }
-
-  // give up the CPU if this is a timer interrupt.
-  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
-    yield();
-
-  // the yield() may have caused some traps to occur,
-  // so restore trap registers for use by kernelvec.S's sepc instruction.
-  w_sepc(sepc);
-  w_sstatus(sstatus);
+    int which_dev = 0;
+    uint64 sepc = r_sepc();
+    uint64 sstatus = r_sstatus();
+    uint64 scause = r_scause();
+
+    if((sstatus & SSTATUS_SPP) == 0)
+        panic("kerneltrap: not from supervisor mode");
+    if(intr_get() != 0)
+        panic("kerneltrap: interrupts enabled");
+
+    if((which_dev = devintr()) == 0){
+        printf("scause %p\n", scause);
+        printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
+        panic("kerneltrap");
+    }
+
+    // give up the CPU if this is a timer interrupt.
+    if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
+        yield();
+
+    // the yield() may have caused some traps to occur,
+    // so restore trap registers for use by kernelvec.S's sepc instruction.
+    w_sepc(sepc);
+    w_sstatus(sstatus);
 }
 
 void
 clockintr()
 {
-  acquire(&tickslock);
-  ticks++;
-  wakeup(&ticks);
-  release(&tickslock);
+    acquire(&tickslock);
+    ticks++;
+    wakeup(&ticks);
+    release(&tickslock);
 }
 
 // check if it's an external interrupt or software interrupt,
@@ -176,45 +185,73 @@ clockintr()
 int
 devintr()
 {
-  uint64 scause = r_scause();
+    uint64 scause = r_scause();
+
+    if((scause & 0x8000000000000000L) &&
+       (scause & 0xff) == 9){
+        // this is a supervisor external interrupt, via PLIC.
+
+        // irq indicates which device interrupted.
+        int irq = plic_claim();
+
+        if(irq == UART0_IRQ){
+            uartintr();
+        } else if(irq == VIRTIO0_IRQ){
+            virtio_disk_intr();
+        } else if(irq){
+            printf("unexpected interrupt irq=%d\n", irq);
+        }
+
+        // the PLIC allows each device to raise at most one
+        // interrupt at a time; tell the PLIC the device is
+        // now allowed to interrupt again.
+        if(irq)
+            plic_complete(irq);
+
+        return 1;
+    } else if(scause == 0x8000000000000001L){
+        // software interrupt from a machine-mode timer interrupt,
+        // forwarded by timervec in kernelvec.S.
+
+        if(cpuid() == 0){
+            clockintr();
+        }
+
+        // acknowledge the software interrupt by clearing
+        // the SSIP bit in sip.
+        w_sip(r_sip() & ~2);
+
+        return 2;
+    } else {
+        return 0;
+    }
+}
 
-  if((scause & 0x8000000000000000L) &&
-     (scause & 0xff) == 9){
-    // this is a supervisor external interrupt, via PLIC.
+int cow_handler(pagetable_t pagetable, uint64 va){
+    pte_t *pte;
+    char *mem;
 
-    // irq indicates which device interrupted.
-    int irq = plic_claim();
+    va = PGROUNDDOWN(va);
+    if(va >= MAXVA)
+        return -1;
+    if ((pte = walk(pagetable, va, 0)) == 0) //pte should exist
+        return -1;
+    if((*pte & PTE_V) == 0) //page not present
+        return -1;
+    if ((*pte & PTE_U) == 0) //not user accessibility
+        return -1;
+    if ((*pte & PTE_COW) == 0)   //not cow
+        return 1;   //returns 1 so when calls from vm - copyout func is not failed from this (it didn't get trap..)
 
-    if(irq == UART0_IRQ){
-      uartintr();
-    } else if(irq == VIRTIO0_IRQ){
-      virtio_disk_intr();
-    } else if(irq){
-      printf("unexpected interrupt irq=%d\n", irq);
-    }
+    if ((mem = kalloc()) == 0)
+        return -1;
 
-    // the PLIC allows each device to raise at most one
-    // interrupt at a time; tell the PLIC the device is
-    // now allowed to interrupt again.
-    if(irq)
-      plic_complete(irq);
+    uint64 pa = PTE2PA(*pte);
+    memmove(mem, (char*)pa, PGSIZE);   //copy page content to mem
 
-    return 1;
-  } else if(scause == 0x8000000000000001L){
-    // software interrupt from a machine-mode timer interrupt,
-    // forwarded by timervec in kernelvec.S.
+    *pte = PA2PTE(mem) | ((PTE_FLAGS(*pte) & ~PTE_COW) | PTE_W);  //set the old pte to point on the new page & set flags
 
-    if(cpuid() == 0){
-      clockintr();
-    }
-    
-    // acknowledge the software interrupt by clearing
-    // the SSIP bit in sip.
-    w_sip(r_sip() & ~2);
+    kfree((void*)pa); //release old page / decrement the reference count
 
-    return 2;
-  } else {
     return 0;
-  }
 }
-
diff --git a/kernel/vm.c b/kernel/vm.c
index d5a12a0..b388281 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -19,41 +19,41 @@ extern char trampoline[]; // trampoline.S
 pagetable_t
 kvmmake(void)
 {
-  pagetable_t kpgtbl;
+    pagetable_t kpgtbl;
 
-  kpgtbl = (pagetable_t) kalloc();
-  memset(kpgtbl, 0, PGSIZE);
+    kpgtbl = (pagetable_t) kalloc();
+    memset(kpgtbl, 0, PGSIZE);
 
-  // uart registers
-  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);
+    // uart registers
+    kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);
 
-  // virtio mmio disk interface
-  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
+    // virtio mmio disk interface
+    kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
 
-  // PLIC
-  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
+    // PLIC
+    kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
 
-  // map kernel text executable and read-only.
-  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
+    // map kernel text executable and read-only.
+    kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
 
-  // map kernel data and the physical RAM we'll make use of.
-  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
+    // map kernel data and the physical RAM we'll make use of.
+    kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
 
-  // map the trampoline for trap entry/exit to
-  // the highest virtual address in the kernel.
-  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
+    // map the trampoline for trap entry/exit to
+    // the highest virtual address in the kernel.
+    kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
 
-  // map kernel stacks
-  proc_mapstacks(kpgtbl);
-  
-  return kpgtbl;
+    // map kernel stacks
+    proc_mapstacks(kpgtbl);
+
+    return kpgtbl;
 }
 
 // Initialize the one kernel_pagetable
 void
 kvminit(void)
 {
-  kernel_pagetable = kvmmake();
+    kernel_pagetable = kvmmake();
 }
 
 // Switch h/w page table register to the kernel's page table,
@@ -61,8 +61,8 @@ kvminit(void)
 void
 kvminithart()
 {
-  w_satp(MAKE_SATP(kernel_pagetable));
-  sfence_vma();
+    w_satp(MAKE_SATP(kernel_pagetable));
+    sfence_vma();
 }
 
 // Return the address of the PTE in page table pagetable
@@ -80,21 +80,21 @@ kvminithart()
 pte_t *
 walk(pagetable_t pagetable, uint64 va, int alloc)
 {
-  if(va >= MAXVA)
-    panic("walk");
-
-  for(int level = 2; level > 0; level--) {
-    pte_t *pte = &pagetable[PX(level, va)];
-    if(*pte & PTE_V) {
-      pagetable = (pagetable_t)PTE2PA(*pte);
-    } else {
-      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
-        return 0;
-      memset(pagetable, 0, PGSIZE);
-      *pte = PA2PTE(pagetable) | PTE_V;
+    if(va >= MAXVA)
+        panic("walk");
+
+    for(int level = 2; level > 0; level--) {
+        pte_t *pte = &pagetable[PX(level, va)];
+        if(*pte & PTE_V) {
+            pagetable = (pagetable_t)PTE2PA(*pte);
+        } else {
+            if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
+                return 0;
+            memset(pagetable, 0, PGSIZE);
+            *pte = PA2PTE(pagetable) | PTE_V;
+        }
     }
-  }
-  return &pagetable[PX(0, va)];
+    return &pagetable[PX(0, va)];
 }
 
 // Look up a virtual address, return the physical address,
@@ -103,21 +103,21 @@ walk(pagetable_t pagetable, uint64 va, int alloc)
 uint64
 walkaddr(pagetable_t pagetable, uint64 va)
 {
-  pte_t *pte;
-  uint64 pa;
+    pte_t *pte;
+    uint64 pa;
 
-  if(va >= MAXVA)
-    return 0;
+    if(va >= MAXVA)
+        return 0;
 
-  pte = walk(pagetable, va, 0);
-  if(pte == 0)
-    return 0;
-  if((*pte & PTE_V) == 0)
-    return 0;
-  if((*pte & PTE_U) == 0)
-    return 0;
-  pa = PTE2PA(*pte);
-  return pa;
+    pte = walk(pagetable, va, 0);
+    if(pte == 0)
+        return 0;
+    if((*pte & PTE_V) == 0)
+        return 0;
+    if((*pte & PTE_U) == 0)
+        return 0;
+    pa = PTE2PA(*pte);
+    return pa;
 }
 
 // add a mapping to the kernel page table.
@@ -126,8 +126,8 @@ walkaddr(pagetable_t pagetable, uint64 va)
 void
 kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
 {
-  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
-    panic("kvmmap");
+    if(mappages(kpgtbl, va, sz, pa, perm) != 0)
+        panic("kvmmap");
 }
 
 // Create PTEs for virtual addresses starting at va that refer to
@@ -137,26 +137,26 @@ kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
 int
 mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
 {
-  uint64 a, last;
-  pte_t *pte;
-
-  if(size == 0)
-    panic("mappages: size");
-  
-  a = PGROUNDDOWN(va);
-  last = PGROUNDDOWN(va + size - 1);
-  for(;;){
-    if((pte = walk(pagetable, a, 1)) == 0)
-      return -1;
-    if(*pte & PTE_V)
-      panic("mappages: remap");
-    *pte = PA2PTE(pa) | perm | PTE_V;
-    if(a == last)
-      break;
-    a += PGSIZE;
-    pa += PGSIZE;
-  }
-  return 0;
+    uint64 a, last;
+    pte_t *pte;
+
+    if(size == 0)
+        panic("mappages: size");
+
+    a = PGROUNDDOWN(va);
+    last = PGROUNDDOWN(va + size - 1);
+    for(;;){
+        if((pte = walk(pagetable, a, 1)) == 0)
+            return -1;
+        if(*pte & PTE_V)
+            panic("mappages: remap");
+        *pte = PA2PTE(pa) | perm | PTE_V;
+        if(a == last)
+            break;
+        a += PGSIZE;
+        pa += PGSIZE;
+    }
+    return 0;
 }
 
 // Remove npages of mappings starting from va. va must be
@@ -165,25 +165,25 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
 void
 uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
 {
-  uint64 a;
-  pte_t *pte;
-
-  if((va % PGSIZE) != 0)
-    panic("uvmunmap: not aligned");
-
-  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
-    if((pte = walk(pagetable, a, 0)) == 0)
-      panic("uvmunmap: walk");
-    if((*pte & PTE_V) == 0)
-      panic("uvmunmap: not mapped");
-    if(PTE_FLAGS(*pte) == PTE_V)
-      panic("uvmunmap: not a leaf");
-    if(do_free){
-      uint64 pa = PTE2PA(*pte);
-      kfree((void*)pa);
+    uint64 a;
+    pte_t *pte;
+
+    if((va % PGSIZE) != 0)
+        panic("uvmunmap: not aligned");
+
+    for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
+        if((pte = walk(pagetable, a, 0)) == 0)
+            panic("uvmunmap: walk");
+        if((*pte & PTE_V) == 0)
+            panic("uvmunmap: not mapped");
+        if(PTE_FLAGS(*pte) == PTE_V)
+            panic("uvmunmap: not a leaf");
+        if(do_free){
+            uint64 pa = PTE2PA(*pte);
+            kfree((void*)pa);
+        }
+        *pte = 0;
     }
-    *pte = 0;
-  }
 }
 
 // create an empty user page table.
@@ -191,12 +191,12 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
 pagetable_t
 uvmcreate()
 {
-  pagetable_t pagetable;
-  pagetable = (pagetable_t) kalloc();
-  if(pagetable == 0)
-    return 0;
-  memset(pagetable, 0, PGSIZE);
-  return pagetable;
+    pagetable_t pagetable;
+    pagetable = (pagetable_t) kalloc();
+    if(pagetable == 0)
+        return 0;
+    memset(pagetable, 0, PGSIZE);
+    return pagetable;
 }
 
 // Load the user initcode into address 0 of pagetable,
@@ -205,14 +205,14 @@ uvmcreate()
 void
 uvminit(pagetable_t pagetable, uchar *src, uint sz)
 {
-  char *mem;
-
-  if(sz >= PGSIZE)
-    panic("inituvm: more than a page");
-  mem = kalloc();
-  memset(mem, 0, PGSIZE);
-  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
-  memmove(mem, src, sz);
+    char *mem;
+
+    if(sz >= PGSIZE)
+        panic("inituvm: more than a page");
+    mem = kalloc();
+    memset(mem, 0, PGSIZE);
+    mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
+    memmove(mem, src, sz);
 }
 
 // Allocate PTEs and physical memory to grow process from oldsz to
@@ -220,27 +220,27 @@ uvminit(pagetable_t pagetable, uchar *src, uint sz)
 uint64
 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 {
-  char *mem;
-  uint64 a;
-
-  if(newsz < oldsz)
-    return oldsz;
-
-  oldsz = PGROUNDUP(oldsz);
-  for(a = oldsz; a < newsz; a += PGSIZE){
-    mem = kalloc();
-    if(mem == 0){
-      uvmdealloc(pagetable, a, oldsz);
-      return 0;
-    }
-    memset(mem, 0, PGSIZE);
-    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){
-      kfree(mem);
-      uvmdealloc(pagetable, a, oldsz);
-      return 0;
+    char *mem;
+    uint64 a;
+
+    if(newsz < oldsz)
+        return oldsz;
+
+    oldsz = PGROUNDUP(oldsz);
+    for(a = oldsz; a < newsz; a += PGSIZE){
+        mem = kalloc();
+        if(mem == 0){
+            uvmdealloc(pagetable, a, oldsz);
+            return 0;
+        }
+        memset(mem, 0, PGSIZE);
+        if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){
+            kfree(mem);
+            uvmdealloc(pagetable, a, oldsz);
+            return 0;
+        }
     }
-  }
-  return newsz;
+    return newsz;
 }
 
 // Deallocate user pages to bring the process size from oldsz to
@@ -250,15 +250,15 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 uint64
 uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 {
-  if(newsz >= oldsz)
-    return oldsz;
+    if(newsz >= oldsz)
+        return oldsz;
 
-  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
-    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
-    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
-  }
+    if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
+        int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
+        uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
+    }
 
-  return newsz;
+    return newsz;
 }
 
 // Recursively free page-table pages.
@@ -266,19 +266,19 @@ uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 void
 freewalk(pagetable_t pagetable)
 {
-  // there are 2^9 = 512 PTEs in a page table.
-  for(int i = 0; i < 512; i++){
-    pte_t pte = pagetable[i];
-    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
-      // this PTE points to a lower-level page table.
-      uint64 child = PTE2PA(pte);
-      freewalk((pagetable_t)child);
-      pagetable[i] = 0;
-    } else if(pte & PTE_V){
-      panic("freewalk: leaf");
+    // there are 2^9 = 512 PTEs in a page table.
+    for(int i = 0; i < 512; i++){
+        pte_t pte = pagetable[i];
+        if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
+            // this PTE points to a lower-level page table.
+            uint64 child = PTE2PA(pte);
+            freewalk((pagetable_t)child);
+            pagetable[i] = 0;
+        } else if(pte & PTE_V){
+            panic("freewalk: leaf");
+        }
     }
-  }
-  kfree((void*)pagetable);
+    kfree((void*)pagetable);
 }
 
 // Free user memory pages,
@@ -286,9 +286,9 @@ freewalk(pagetable_t pagetable)
 void
 uvmfree(pagetable_t pagetable, uint64 sz)
 {
-  if(sz > 0)
-    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
-  freewalk(pagetable);
+    if(sz > 0)
+        uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
+    freewalk(pagetable);
 }
 
 // Given a parent process's page table, copy
@@ -300,31 +300,27 @@ uvmfree(pagetable_t pagetable, uint64 sz)
 int
 uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
 {
-  pte_t *pte;
-  uint64 pa, i;
-  uint flags;
-  char *mem;
-
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walk(old, i, 0)) == 0)
-      panic("uvmcopy: pte should exist");
-    if((*pte & PTE_V) == 0)
-      panic("uvmcopy: page not present");
-    pa = PTE2PA(*pte);
-    flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto err;
-    memmove(mem, (char*)pa, PGSIZE);
-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
-      kfree(mem);
-      goto err;
+    pte_t *pte;
+    uint64 pa, i;
+    uint flags;
+
+    for(i = 0; i < sz; i += PGSIZE){
+        if((pte = walk(old, i, 0)) == 0)
+            panic("uvmcopy: pte should exist");
+        if((*pte & PTE_V) == 0)
+            panic("uvmcopy: page not present");
+        pa = PTE2PA(*pte);
+        flags = PTE_FLAGS(*pte);
+        if(mappages(new, i, PGSIZE, (uint64)pa, flags) != 0)
+            goto err;
+        inc_reference_count(pa);
+        *pte = ((*pte) & (~PTE_W)) | PTE_COW;   //changed to be read only and add cow flag
     }
-  }
-  return 0;
+    return 0;
 
- err:
-  uvmunmap(new, 0, i / PGSIZE, 1);
-  return -1;
+    err:
+    uvmunmap(new, 0, i / PGSIZE, 1);
+    return -1;
 }
 
 // mark a PTE invalid for user access.
@@ -332,12 +328,12 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
 void
 uvmclear(pagetable_t pagetable, uint64 va)
 {
-  pte_t *pte;
-  
-  pte = walk(pagetable, va, 0);
-  if(pte == 0)
-    panic("uvmclear");
-  *pte &= ~PTE_U;
+    pte_t *pte;
+
+    pte = walk(pagetable, va, 0);
+    if(pte == 0)
+        panic("uvmclear");
+    *pte &= ~PTE_U;
 }
 
 // Copy from kernel to user.
@@ -346,23 +342,25 @@ uvmclear(pagetable_t pagetable, uint64 va)
 int
 copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 {
-  uint64 n, va0, pa0;
-
-  while(len > 0){
-    va0 = PGROUNDDOWN(dstva);
-    pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (dstva - va0);
-    if(n > len)
-      n = len;
-    memmove((void *)(pa0 + (dstva - va0)), src, n);
-
-    len -= n;
-    src += n;
-    dstva = va0 + PGSIZE;
-  }
-  return 0;
+    uint64 n, va0, pa0;
+
+    while(len > 0){
+        va0 = PGROUNDDOWN(dstva);
+        if (cow_handler(pagetable, va0) < 0)
+            return -1;
+        pa0 = walkaddr(pagetable, va0);
+        if(pa0 == 0)
+            return -1;
+        n = PGSIZE - (dstva - va0);
+        if(n > len)
+            n = len;
+        memmove((void *)(pa0 + (dstva - va0)), src, n);
+
+        len -= n;
+        src += n;
+        dstva = va0 + PGSIZE;
+    }
+    return 0;
 }
 
 // Copy from user to kernel.
@@ -371,23 +369,23 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 int
 copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
 {
-  uint64 n, va0, pa0;
-
-  while(len > 0){
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (srcva - va0);
-    if(n > len)
-      n = len;
-    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
-
-    len -= n;
-    dst += n;
-    srcva = va0 + PGSIZE;
-  }
-  return 0;
+    uint64 n, va0, pa0;
+
+    while(len > 0){
+        va0 = PGROUNDDOWN(srcva);
+        pa0 = walkaddr(pagetable, va0);
+        if(pa0 == 0)
+            return -1;
+        n = PGSIZE - (srcva - va0);
+        if(n > len)
+            n = len;
+        memmove(dst, (void *)(pa0 + (srcva - va0)), n);
+
+        len -= n;
+        dst += n;
+        srcva = va0 + PGSIZE;
+    }
+    return 0;
 }
 
 // Copy a null-terminated string from user to kernel.
@@ -397,38 +395,39 @@ copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
 int
 copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
 {
-  uint64 n, va0, pa0;
-  int got_null = 0;
-
-  while(got_null == 0 && max > 0){
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (srcva - va0);
-    if(n > max)
-      n = max;
-
-    char *p = (char *) (pa0 + (srcva - va0));
-    while(n > 0){
-      if(*p == '\0'){
-        *dst = '\0';
-        got_null = 1;
-        break;
-      } else {
-        *dst = *p;
-      }
-      --n;
-      --max;
-      p++;
-      dst++;
+    uint64 n, va0, pa0;
+    int got_null = 0;
+
+    while(got_null == 0 && max > 0){
+        va0 = PGROUNDDOWN(srcva);
+        pa0 = walkaddr(pagetable, va0);
+        if(pa0 == 0)
+            return -1;
+        n = PGSIZE - (srcva - va0);
+        if(n > max)
+            n = max;
+
+        char *p = (char *) (pa0 + (srcva - va0));
+        while(n > 0){
+            if(*p == '\0'){
+                *dst = '\0';
+                got_null = 1;
+                break;
+            } else {
+                *dst = *p;
+            }
+            --n;
+            --max;
+            p++;
+            dst++;
+        }
+
+        srcva = va0 + PGSIZE;
+    }
+    if(got_null){
+        return 0;
+    } else {
+        return -1;
     }
-
-    srcva = va0 + PGSIZE;
-  }
-  if(got_null){
-    return 0;
-  } else {
-    return -1;
-  }
 }
+
diff --git a/user/usys.pl b/user/usys.pl
old mode 100755
new mode 100644
